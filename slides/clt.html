<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Central Limit Theorem (Interactive Simulation)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#121a33;
      --panel2:#0f1730;
      --ink:#e6ecff;
      --muted:#a8b6ff;
      --accent:#6ee7ff;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#f59e0b;
      --danger:#fb7185;
      --grid:rgba(255,255,255,.08);
      --border:rgba(255,255,255,.10);
    }
    html,body{height:100%;margin:0}
    body{
      background: radial-gradient(1000px 800px at 60% -200px, rgba(110,231,255,.08), rgba(0,0,0,0)),
                  radial-gradient(900px 700px at 0% 0%, rgba(167,139,250,.10), rgba(0,0,0,0)),
                  linear-gradient(180deg,#0b1020,#070a14);
      color:var(--ink);
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,Ubuntu,Cantarell,Inter,Arial,sans-serif;
    }
    .wrap{
      max-width:1200px;
      margin:20px auto;
      padding:0 16px 24px;
      display:grid;
      grid-template-columns:360px 1fr;
      gap:16px;
      align-items:start;
    }
    .panel{
      background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.03));
      border:1px solid var(--border);
      border-radius:16px;
      padding:14px;
      box-shadow:0 12px 40px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.04);
    }
    h1{font-size:18px;margin:0 0 6px;letter-spacing:.2px}
    .sub{color:var(--muted);font-size:12px;margin:0 0 12px;line-height:1.35}
    .controls{display:grid;gap:10px}
    .row{display:flex;gap:10px;align-items:center}
    .row label{flex:1 1 auto;font-size:12px;color:var(--muted)}
    .row input[type="range"]{flex:2 1 auto}
    select, input[type="number"]{
      width:100%;
      background:rgba(255,255,255,.04);
      color:var(--ink);
      border:1px solid rgba(255,255,255,.12);
      border-radius:12px;
      padding:10px 12px;
      font-size:13px;
      outline:none;
    }
    .btns{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:6px}
    button{
      background:linear-gradient(180deg,#1b264f,#162042);
      color:var(--ink);
      border:1px solid rgba(255,255,255,.12);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:700;
      font-size:12px;
    }
    button:hover{filter:brightness(1.08)}
    button:disabled{opacity:.55;cursor:not-allowed}
    .grid2{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:8px;
      margin-top:10px
    }
    .card{
      background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.06);
      border-radius:12px;
      padding:10px;
    }
    .card b{display:block;font-size:11px;color:var(--muted);margin-bottom:5px}
    .mono{font-variant-numeric:tabular-nums; font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
    .hint{margin-top:10px;color:var(--muted);font-size:12px;line-height:1.35}
    .canvases{display:grid;gap:14px}
    .plotTitle{display:flex;justify-content:space-between;align-items:baseline;margin:0 0 8px}
    .plotTitle h2{margin:0;font-size:14px}
    .plotTitle span{color:var(--muted);font-size:12px}
    canvas{
      width:100%;
      height:auto;
      border-radius:16px;
      background:radial-gradient(1000px 500px at 50% -200px, rgba(110,231,255,.06), rgba(0,0,0,0));
      border:1px solid rgba(255,255,255,.08);
    }
    .legend{
      margin-top:8px;
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      align-items:center;
      color:var(--muted);
      font-size:11px;
    }
    .swatch{width:12px;height:12px;border-radius:3px;display:inline-block}
    .sw-x{background:linear-gradient(180deg,#60a5fa,#3b82f6)}
    .sw-xbar{background:linear-gradient(180deg,#34d399,#10b981)}
    .sw-norm{background:linear-gradient(180deg,#a78bfa,#8b5cf6)}
    @media (max-width: 980px){
      .wrap{grid-template-columns:1fr}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <section class="panel">
      <h1>Central Limit Theorem (CLT) Simulator</h1>
      <p class="sub">
        Choose a distribution for <span class="mono">X</span>, then repeatedly sample <span class="mono">n</span> values and plot the
        distribution of the sample mean <span class="mono">X̄</span>. With larger <span class="mono">n</span>, <span class="mono">X̄</span> becomes approximately normal.
      </p>

      <div class="controls">
        <div>
          <label for="dist" class="sub" style="display:block;margin:0 0 6px">Distribution of X</label>
          <select id="dist">
            <option value="uniform01">Uniform(0, 1)</option>
            <option value="exponential1">Exponential(rate=1)</option>
            <option value="bernoulli03">Bernoulli(p=0.3)</option>
            <option value="lognormal">Lognormal(0, 1)</option>
            <option value="bimodal">Bimodal mixture</option>
            <option value="studentT5">Student t (df=5)</option>
          </select>
        </div>

        <div class="row">
          <label>Sample size n (<span id="nOut" class="mono">10</span>)</label>
          <input id="n" type="range" min="1" max="200" value="10" />
        </div>

        <div class="row">
          <label>Samples per second (<span id="rateOut" class="mono">30</span>)</label>
          <input id="rate" type="range" min="1" max="240" value="30" />
        </div>

        <div class="row">
          <label>Histogram bins (<span id="binsOut" class="mono">35</span>)</label>
          <input id="bins" type="range" min="10" max="80" value="35" />
        </div>

        <div class="row">
          <label>Show normal approximation</label>
          <input id="showNormal" type="checkbox" checked />
        </div>

        <div class="btns">
          <button id="step1">Add 1 mean</button>
          <button id="step100">Add 100</button>
          <button id="auto">Auto-run</button>
          <button id="pause">Pause</button>
          <button id="reset">Reset</button>
          <button id="clear">Clear means</button>
        </div>

        <div class="grid2">
          <div class="card">
            <b>Total means (m)</b>
            <div id="mOut" class="mono">0</div>
          </div>
          <div class="card">
            <b>n × m draws</b>
            <div id="drawsOut" class="mono">0</div>
          </div>
          <div class="card">
            <b>Mean of means (≈ μ)</b>
            <div id="meanMeansOut" class="mono">—</div>
          </div>
          <div class="card">
            <b>SD of means (≈ σ/√n)</b>
            <div id="sdMeansOut" class="mono">—</div>
          </div>
        </div>

        <p class="hint">
          Suggested activity: pick a skewed distribution (Exponential or Lognormal). Try <span class="mono">n=1</span>, then <span class="mono">n=5</span>, <span class="mono">n=30</span>.
          Watch how the <span class="mono">X̄</span> histogram becomes more bell-shaped and tighter around its centre.
        </p>
      </div>
    </section>

    <section class="canvases">
      <div class="panel" style="padding:14px">
        <div class="plotTitle">
          <h2>Distribution of X (raw draws)</h2>
          <span class="mono" id="xStats">—</span>
        </div>
        <canvas id="xCanvas" width="900" height="260"></canvas>
        <div class="legend">
          <span class="swatch sw-x"></span> Histogram of X
        </div>
      </div>

      <div class="panel" style="padding:14px">
        <div class="plotTitle">
          <h2>Distribution of X̄ (sample means)</h2>
          <span class="mono" id="xbarStats">—</span>
        </div>
        <canvas id="xbarCanvas" width="900" height="320"></canvas>
        <div class="legend">
          <span class="swatch sw-xbar"></span> Histogram of X̄
          <span class="swatch sw-norm"></span> Normal approximation
        </div>
      </div>
    </section>
  </div>

  <script>
  (function(){
    // ---------- Utilities ----------
    function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
    function fmt(x, digits=4){
      if(!isFinite(x)) return "—";
      // show fewer digits for large values
      const abs = Math.abs(x);
      if(abs >= 1000) return x.toFixed(1);
      if(abs >= 100) return x.toFixed(2);
      if(abs >= 10) return x.toFixed(3);
      return x.toFixed(digits);
    }
    function lerp(a,b,t){ return a + (b-a)*t; }

    // Standard normal via Box-Muller
    function randn(){
      let u = 0, v = 0;
      while(u === 0) u = Math.random();
      while(v === 0) v = Math.random();
      return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0*Math.PI*v);
    }
    // Gamma(k, theta) for k = df/2 using Marsaglia-Tsang (k>1)
    function randGamma(shape){
      // shape > 1
      const d = shape - 1/3;
      const c = 1/Math.sqrt(9*d);
      while(true){
        let x = randn();
        let v = 1 + c*x;
        if(v <= 0) continue;
        v = v*v*v;
        const u = Math.random();
        if(u < 1 - 0.0331*(x*x)*(x*x)) return d*v;
        if(Math.log(u) < 0.5*x*x + d*(1 - v + Math.log(v))) return d*v;
      }
    }
    // Student-t via Normal / sqrt(ChiSq/df)
    function randStudentT(df){
      // Chi-square(df) = 2*Gamma(df/2)
      const z = randn();
      // df/2 can be <=1 for small df; we only use df=5 here so ok
      const g = randGamma(df/2);
      const chisq = 2*g;
      return z / Math.sqrt(chisq/df);
    }

    // ---------- Distributions ----------
    const distDefs = {
      uniform01: {
        name: "Uniform(0,1)",
        sample: () => Math.random(),
        mu: 0.5,
        sigma: Math.sqrt(1/12),
        xRange: [0, 1]
      },
      exponential1: {
        name: "Exponential(1)",
        sample: () => -Math.log(1 - Math.random()), // rate=1
        mu: 1,
        sigma: 1,
        xRange: [0, 8]
      },
      bernoulli03: {
        name: "Bernoulli(0.3)",
        sample: () => (Math.random() < 0.3 ? 1 : 0),
        mu: 0.3,
        sigma: Math.sqrt(0.3*0.7),
        xRange: [-0.1, 1.1]
      },
      lognormal: {
        name: "Lognormal(0,1)",
        sample: () => Math.exp(randn()),
        // For Lognormal(0,1): mean = exp(1/2), var = (exp(1)-1)*exp(1)
        mu: Math.exp(0.5),
        sigma: Math.sqrt((Math.exp(1)-1)*Math.exp(1)),
        xRange: [0, 15]
      },
      bimodal: {
        name: "Bimodal mixture",
        sample: () => {
          // 50/50 mixture of two normals
          return (Math.random() < 0.5) ? (-2 + 0.6*randn()) : (2 + 0.9*randn());
        },
        // mixture mean and variance:
        // E[X] = 0.5*(-2)+0.5*(2) = 0
        // Var = E[Var|comp] + Var(E[X|comp]) = 0.5*0.6^2 + 0.5*0.9^2 + Var([-2,2]) where Var = 4
        mu: 0,
        sigma: Math.sqrt(0.5*(0.6*0.6) + 0.5*(0.9*0.9) + 4),
        xRange: [-6, 6]
      },
      studentT5: {
        name: "Student t (df=5)",
        sample: () => randStudentT(5),
        mu: 0,
        sigma: Math.sqrt(5/(5-2)), // df/(df-2) for df>2
        xRange: [-8, 8]
      }
    };

    // ---------- State ----------
    const el = {
      dist: document.getElementById("dist"),
      n: document.getElementById("n"),
      rate: document.getElementById("rate"),
      bins: document.getElementById("bins"),
      showNormal: document.getElementById("showNormal"),

      nOut: document.getElementById("nOut"),
      rateOut: document.getElementById("rateOut"),
      binsOut: document.getElementById("binsOut"),

      step1: document.getElementById("step1"),
      step100: document.getElementById("step100"),
      auto: document.getElementById("auto"),
      pause: document.getElementById("pause"),
      reset: document.getElementById("reset"),
      clear: document.getElementById("clear"),

      mOut: document.getElementById("mOut"),
      drawsOut: document.getElementById("drawsOut"),
      meanMeansOut: document.getElementById("meanMeansOut"),
      sdMeansOut: document.getElementById("sdMeansOut"),

      xStats: document.getElementById("xStats"),
      xbarStats: document.getElementById("xbarStats"),

      xCanvas: document.getElementById("xCanvas"),
      xbarCanvas: document.getElementById("xbarCanvas")
    };

    const xCtx = el.xCanvas.getContext("2d");
    const xbarCtx = el.xbarCanvas.getContext("2d");

    let distKey = el.dist.value;
    let n = parseInt(el.n.value, 10);
    let rate = parseInt(el.rate.value, 10);
    let binCount = parseInt(el.bins.value, 10);
    let autorun = false;
    let lastTime = performance.now();
    let carry = 0;

    // raw draws buffer (for X histogram)
    const X_KEEP = 20000;
    let xBuf = [];

    // sample means
    let xbar = [];

    // Welford running stats for means
    let mCount = 0;
    let mMean = 0;
    let mM2 = 0;

    // Running stats for X (raw draws), also Welford
    let xCount = 0;
    let xMean = 0;
    let xM2 = 0;

    function welfordPush(state, value){
      state.count += 1;
      const delta = value - state.mean;
      state.mean += delta / state.count;
      const delta2 = value - state.mean;
      state.M2 += delta * delta2;
    }
    function welfordReset(){ return {count:0, mean:0, M2:0}; }
    let xStat = welfordReset();
    let mStat = welfordReset();

    // ---------- Histogram helper ----------
    function histogram(data, minX, maxX, bins){
      const counts = new Array(bins).fill(0);
      if(data.length === 0) return counts;
      const span = (maxX - minX) || 1;
      for(const v of data){
        const t = (v - minX) / span;
        let i = Math.floor(t * bins);
        if(i < 0) i = 0;
        if(i >= bins) i = bins - 1;
        counts[i] += 1;
      }
      return counts;
    }

    // ---------- Drawing ----------
    function drawGrid(ctx, W, H, pad){
      ctx.save();
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue("--grid").trim() || "rgba(255,255,255,.08)";
      ctx.lineWidth = 1;
      const gx = 6, gy = 4;
      for(let i=0;i<=gx;i++){
        const x = lerp(pad.l, W-pad.r, i/gx);
        ctx.beginPath();
        ctx.moveTo(x, pad.t);
        ctx.lineTo(x, H-pad.b);
        ctx.stroke();
      }
      for(let j=0;j<=gy;j++){
        const y = lerp(pad.t, H-pad.b, j/gy);
        ctx.beginPath();
        ctx.moveTo(pad.l, y);
        ctx.lineTo(W-pad.r, y);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawHistogramPlot(ctx, data, minX, maxX, bins, barColor, overlayFn){
      const W = ctx.canvas.width, H = ctx.canvas.height;
      const pad = {l:50, r:18, t:18, b:34};
      ctx.clearRect(0,0,W,H);
      drawGrid(ctx, W, H, pad);

      // axis
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.25)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(pad.l, H-pad.b);
      ctx.lineTo(W-pad.r, H-pad.b);
      ctx.moveTo(pad.l, pad.t);
      ctx.lineTo(pad.l, H-pad.b);
      ctx.stroke();
      ctx.restore();

      const counts = histogram(data, minX, maxX, bins);
      const maxC = Math.max(1, ...counts);
      const width = (W - pad.l - pad.r);
      const height = (H - pad.t - pad.b);
      const barW = width / bins;

      // bars
      ctx.save();
      ctx.fillStyle = barColor;
      for(let i=0;i<bins;i++){
        const c = counts[i];
        const h = (c / maxC) * height;
        const x0 = pad.l + i*barW + 1;
        const y0 = (H - pad.b) - h;
        ctx.fillRect(x0, y0, Math.max(1, barW - 2), h);
      }
      ctx.restore();

      // overlay function (draw in density-like scaling)
      if(typeof overlayFn === "function" && data.length > 5){
        // build polyline in canvas coords
        const N = 300;
        let maxY = 0;
        const pts = [];
        for(let i=0;i<=N;i++){
          const x = minX + (i/N)*(maxX-minX);
          const y = overlayFn(x);
          if(isFinite(y)) maxY = Math.max(maxY, y);
          pts.push([x,y]);
        }
        // scale overlay to histogram height using peak alignment:
        // histogram peak corresponds to maxC counts in a bin of width (range/bins)
        const binWidth = (maxX - minX) / bins;
        const total = data.length;
        // convert density to expected counts in a bin: density * total * binWidth
        const toCount = (y) => y * total * binWidth;
        const overlayMaxCount = Math.max(1e-12, ...pts.map(p => toCount(p[1])));
        ctx.save();
        ctx.beginPath();
        for(let i=0;i<pts.length;i++){
          const x = pts[i][0];
          const yCount = toCount(pts[i][1]);
          const xpx = pad.l + ((x - minX)/(maxX-minX)) * width;
          const ypx = (H - pad.b) - (yCount / Math.max(maxC, overlayMaxCount)) * height;
          if(i===0) ctx.moveTo(xpx, ypx); else ctx.lineTo(xpx, ypx);
        }
        ctx.strokeStyle = "#a78bfa";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.restore();
      }

      // x-axis labels (min/max)
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.70)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      ctx.textAlign = "left";
      ctx.fillText(fmt(minX,3), pad.l, H - 10);
      ctx.textAlign = "right";
      ctx.fillText(fmt(maxX,3), W - pad.r, H - 10);
      ctx.restore();
    }

    // ---------- Simulation ----------
    function currentDist(){ return distDefs[distKey]; }

    function resetAll(){
      autorun = false;
      el.auto.textContent = "Auto-run";
      xBuf = [];
      xbar = [];
      xStat = welfordReset();
      mStat = welfordReset();
      carry = 0;
      draw();
      updateReadouts();
    }

    function clearMeans(){
      autorun = false;
      el.auto.textContent = "Auto-run";
      xbar = [];
      mStat = welfordReset();
      carry = 0;
      draw();
      updateReadouts();
    }

    function addOneMean(){
      const def = currentDist();
      let sum = 0;
      for(let i=0;i<n;i++){
        const x = def.sample();
        sum += x;
        xBuf.push(x);
        if(xBuf.length > X_KEEP) xBuf.shift();
        welfordPush(xStat, x);
      }
      const xb = sum / n;
      xbar.push(xb);
      welfordPush(mStat, xb);
    }

    function addManyMeans(k){
      for(let i=0;i<k;i++) addOneMean();
    }

    function updateReadouts(){
      const def = currentDist();
      el.nOut.textContent = String(n);
      el.rateOut.textContent = String(rate);
      el.binsOut.textContent = String(binCount);

      const m = xbar.length;
      el.mOut.textContent = String(m);
      el.drawsOut.textContent = String(m * n);

      const mVar = (mStat.count > 1) ? (mStat.M2 / (mStat.count - 1)) : NaN;
      const mSd = Math.sqrt(mVar);
      el.meanMeansOut.textContent = isFinite(mStat.mean) && m>0 ? fmt(mStat.mean, 5) : "—";
      el.sdMeansOut.textContent = isFinite(mSd) ? fmt(mSd, 5) : "—";

      const xVar = (xStat.count > 1) ? (xStat.M2 / (xStat.count - 1)) : NaN;
      const xSd = Math.sqrt(xVar);

      // theoretical SE from known sigma, if available
      const seTheo = def.sigma / Math.sqrt(n);

      el.xStats.textContent =
        (xStat.count > 0)
          ? `draws=${xStat.count}  mean=${fmt(xStat.mean,5)}  sd=${fmt(xSd,5)}`
          : "—";

      el.xbarStats.textContent =
        (m > 0)
          ? `m=${m}  mean(X̄)=${fmt(mStat.mean,5)}  sd(X̄)=${fmt(mSd,5)}  theo sd≈${fmt(seTheo,5)}`
          : "—";
    }

    function draw(){
      const def = currentDist();
      // X plot range
      const xMin = def.xRange[0], xMax = def.xRange[1];

      // X̄ range: use theory ± 4*SE around mu when possible; fall back to data quantiles
      const mu = def.mu;
      const se = def.sigma / Math.sqrt(n);
      let xbMin = mu - 4*se;
      let xbMax = mu + 4*se;
      if(xbar.length >= 20){
        // expand if data outside
        let minD = Infinity, maxD = -Infinity;
        for(const v of xbar){ if(v<minD) minD=v; if(v>maxD) maxD=v; }
        const pad = 0.05 * (maxD - minD || 1);
        xbMin = Math.min(xbMin, minD - pad);
        xbMax = Math.max(xbMax, maxD + pad);
      }
      if(!isFinite(xbMin) || !isFinite(xbMax) || xbMin === xbMax){
        xbMin = mu - 1;
        xbMax = mu + 1;
      }

      // Draw X histogram
      drawHistogramPlot(
        xCtx,
        xBuf,
        xMin,
        xMax,
        Math.min(80, Math.max(10, Math.floor(binCount*0.8))),
        "#60a5fa",
        null
      );

      // Normal approximation overlay for X̄: N(mu, sigma^2/n)
      const showN = el.showNormal.checked;
      const sigmaXbar = def.sigma / Math.sqrt(n);
      function normalPdf(x){
        const s = sigmaXbar || 1e-9;
        const z = (x - mu) / s;
        return (1/Math.sqrt(2*Math.PI)) * Math.exp(-0.5*z*z) / s;
      }

      drawHistogramPlot(
        xbarCtx,
        xbar,
        xbMin,
        xbMax,
        binCount,
        "#34d399",
        (showN ? normalPdf : null)
      );
    }

    // ---------- Animation loop ----------
    function tick(){
      const now = performance.now();
      const dt = (now - lastTime)/1000;
      lastTime = now;

      if(autorun){
        carry += dt * rate;
        const k = Math.floor(carry);
        if(k > 0){
          carry -= k;
          // Safety: avoid freezing on huge dt
          const kk = Math.min(k, 800);
          addManyMeans(kk);
          updateReadouts();
          draw();
        }
      }
      requestAnimationFrame(tick);
    }

    // ---------- UI wiring ----------
    el.dist.addEventListener("change", ()=>{
      distKey = el.dist.value;
      resetAll();
    });
    el.n.addEventListener("input", ()=>{
      n = parseInt(el.n.value, 10);
      el.nOut.textContent = String(n);
      // keep means, but redraw with new theory overlay; practical: clear means for clarity
      clearMeans();
    });
    el.rate.addEventListener("input", ()=>{
      rate = parseInt(el.rate.value, 10);
      el.rateOut.textContent = String(rate);
    });
    el.bins.addEventListener("input", ()=>{
      binCount = parseInt(el.bins.value, 10);
      el.binsOut.textContent = String(binCount);
      draw();
    });
    el.showNormal.addEventListener("change", ()=> draw());

    el.step1.addEventListener("click", ()=>{
      addManyMeans(1);
      updateReadouts();
      draw();
    });
    el.step100.addEventListener("click", ()=>{
      addManyMeans(100);
      updateReadouts();
      draw();
    });
    el.auto.addEventListener("click", ()=>{
      autorun = !autorun;
      el.auto.textContent = autorun ? "Auto-running…" : "Auto-run";
    });
    el.pause.addEventListener("click", ()=>{
      autorun = false;
      el.auto.textContent = "Auto-run";
    });
    el.reset.addEventListener("click", resetAll);
    el.clear.addEventListener("click", clearMeans);

    // Crisp canvases on resize
    function resizeCanvases(){
      const ratio = window.devicePixelRatio || 1;
      // Match canvas width to CSS width while keeping internal pixel density
      for(const c of [el.xCanvas, el.xbarCanvas]){
        const box = c.getBoundingClientRect();
        const w = Math.max(700, Math.floor(box.width * ratio));
        if(c.width !== w) c.width = w;
      }
      // fixed heights, scaled for ratio
      el.xCanvas.height = Math.floor(260 * ratio);
      el.xbarCanvas.height = Math.floor(320 * ratio);
      draw();
    }
    window.addEventListener("resize", resizeCanvases);

    // Init
    resizeCanvases();
    updateReadouts();
    draw();
    requestAnimationFrame(tick);
  })();
  </script>
</body>
</html>
